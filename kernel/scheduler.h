/*
 * スケジューラ選択システムコールはデフォルトで設定する場合，必ず
 * start_init_tsk()の最初で行う．行わなかった場合の動作は保証しない.
 * FCFSスケジューリングやラウンドロビンスケジューリングをして
 * いる時は，initタスクをidleタスクとしては使用しないように
 * する(idleタスクは無限ループをして省電力モード移行命令を
 * 発行し続けるため，タスクの切り替えができない)．到着順に実行し,
 * システムコール発行契機でタスクを切り替えるため，ずっとidleと
 * なってしまう．優先度スケジューリングのようなidleタスクを使用
 * したい場合は，別途，別のidle専用キューなどを設ける必要があるが，
 * ここではしない．
 * また，優先度を持っていないスケジューラは優先度に依存するシステム
 * コールはすべてE_NOSPTを返却するものとする．(優先度取得,
 * 優先度変更，優先度回転，優先度逆転機構)
 * タイムスライス系のスケジューリングをしている時はタスクの実行結果
 * を見る時注意する．何秒間実行させるという事ができない場合は
 * ユーザタスク内で無限ループを作り，タイムカウントで見たりなど,
 * -Multilevel Feed Back Queue
 * ・高優先度に最も短いスライスタイムを付け，低優先度にいくにつれて,
 *   長いスライスタイムを付ける
 * ・スライスタイムへの変化は優先度で重みづけする(学習OSなので，簡単に
 *   した)
 * ・また，タイムアウトしたタスクは優先度を一つ下げる
 * ・CPUバウンドタスクよりI/Oバウンドタスクが優先されてスケジュールさ
 *   れる.
 * ・システムコールでデフォルトのスライスタイムを受け取り，スライスタ
 *   イムと優先度を乗算し，重みづけする.
 * ・各優先度レベルでのスライスタイムを決定させている.また最低優先度は
 *   ラウンドロビンとなる.
 * -簡易O(1)スケジューリング(Linuxカーネル2.6.11スケジューラ)は
 *  タイムアウトと優先度レベルのキューのデータ構造のみを実装した．
 *  ・データ構造のみ実装した理由は，平均休止時間を求めるコードを全タス
 *   ク分行っていると膨大になるのと，ソフトタイマが一つしか実装されて
 *   いない事(誤差が大きくなる)，scheduler.c以外でのコードが他のスケ
 *   ジューラ依存部とごちゃごちゃになったから．
 *  ・タイムクォンタムは重みをパラメータで受け取りタイムクォンタムを求
 *    める式に乗算する(h8はクロックが20MHzで遅いため).重みは100より
 *    大きい数にしないと16~31までの優先度のタスクが実行できなくなる
 *    (100がちょうどいい)
 * -Fair Scheduling
 * ・CPUバウンドタスク,I/Oバウンドタスクをヒューリスティックを使用せず
 *  に,公平にスケジューリングする.
 * ・優先度は動的とし,スケジューラが決定する.レディーの構造はツリーと
 *  し,実行時間で管理する.
 * -Priority Fair Scheduling
 * ・CPUバウンドタスク,I/Oバウンドタスクをヒューリスティックを使用せず
 *  に,優先度レベルで公平にスケジューリングする.
 * ・優先度は動的優先度と静的優先度の2通り.動的優先度はスケジューラが,
 *   静的優先度はユーザが管理する.
 * -Rate Monotonic
 * ・Rate Monotonicは静的優先度ポリシーなので固定優先度はacre_tsk()
 *   システムコール時にユーザが決定する(周期の短い順に優先度をつける).
 *   OS側でのデータ構造は優先度レベルのキューをもっておき優先度スケジュ
 *   ーリング行い,デッドラインチェックとなる.デッドラインは相対デッドラ
 *   インと,周期と同じにする.
 * ・周期タスクは周期ハンドラと非タスクコンテキスト用システムコールist
 *   a_tsk()を使用して行う.(3つの周期タスクを生成する時は周期ハンドラ
 * 3つ)
 * ・デッドラインをミスするタスクセットが起動された時はタスク起動の段階で
 *   (スケジューリングの段階ではない)デッドラインミスハンドラを呼ぶ.
 * ・RM時は排他や同期をしていいけない同期や排他機能を許してしまうと,デッ
 *  ドラインの計算がNP困難となる(EDFも同様).よって排他と同期システムコー
 *  ル(slp_tsk(),tslp_tsk,dly_tsk(),acre_tsk(),acre_mtx())を無効にし
 *  た.さらに,RMは周期で優先度を決定しているので,chg_pri()を無効,rot_d
 *  tq(),chg_slt(),get_slt()を無効にした.
 * -Deadline Monotonic
 * ・RMの周期とデッドラインが異なるスケジューリングで他はRMのほぼ同じ.
 * ・展開スケジュールはデッドライン時刻と実行時間で行う.
 * -Earliest Deadline First
 * ・デッドラインの早いものから動的に優先度を割付ていくスケジューリング
 *  なので，アプリケーション側で優先度を決定はできない．そのため，2分木
 *  と単一のデッドラインで整列した双方向リストを用いて実装した．整列リス
 *   トを使用したのは動的優先度の管理を簡単にするためである．
 * ・デッドラインのみでスケジューリングするので，周期タスクセットにも適
 *  用できる．
 * ・デッドラインをミスした時はRMと同様にデッドラインミスハンドラを呼ぶ．
 *   そのため，デッドライン時刻でタイマを使用している．(タイマ解除はス
 *   ライス型スケジューリングのプリエンプトの段階でなく，タスク休止状態
 *   や未登録状態に遷移した時に行う)．またdomino effectを防ぐため，デ
 *   ッドラインミスしたタスクが存在したら，デッドラインミスハンドラ内で
 *   OSをスリープさせている．
 * ・RMと同様に同期や排他機能を無効にした.優先度はスケジューラが管理す
 *   るので,chg_pri()を無効,他rot_dtq(),chg_slt(),get_slt()を無効に
 *   した.
 * -Least Laxity First
 * ・余裕時刻の早いものから動的に優先度を割り付けていくスケジューリング
 *   で,内部構造はEDFと同じである.
 * ・余裕時刻をミスすれば,必然的にデッドラインをミスするので,LLFもミス
 *   ハンドラを呼ぶ実装とした.
 * -スケジューラ属性はスケジューラの動的切り替えを行う時,システムコー
 *  ルを発行したら切り替えるか,のTA_EXECHGとタスクが終了したら切り替え
 *  るTA_EXITCHGがある．
 */


#ifndef _SCHEDULER_H_INCLUDED_
#define _SCHEDULER_H_INCLUDED_


#include "defines.h"
#include "kernel.h"
#include "ready.h"


/*! スケジューラコントロールブロック */
/*
 * ～スケジューラが個別に持つ情報～
 */
typedef struct {
  union {
    /*! FCFSスケジューリングエリア  */
    struct {
      void (*rte)(void);        /*! スケジューラへのポインタ */
    } fcfs_schdul;
    /*! ラウンドロビンスケジューリングエリア */
    struct {
#define RR_TIME_SLICE 1000        /*! RRスケジューリング,タイムスライスデフォルト値 */
      int tmout;                  /*! スケジューラへ渡すパラメータ(デフォルト時でのタイムスライス) */
      TMR_OBJP tobjp;             /*! スケジューラが使用する対象タイマコントロールブロックを記録 */
      void (*rte)(void);        /*! スケジューラへのポインタ */
    } rr_schdul;
    /*! 優先度スケジューリングエリア */
    struct {
      void (*rte)(void);        /*! スケジューラへのポインタ */
    } ps_schdul;
    /*! ラウンドロビン×優先度スケジューリングエリア */
    struct {
#define RPS_TIME_SLICE 1000       /*! RPスケジューリングタイムスライスデフォルト値 */
      int tmout;                  /*! スケジューラへ渡すパラメータ(デフォルト時でのタイムスライス) */
      TMR_OBJP tobjp;             /*! スケジューラが使用する対象タイマコントロールブロックを記録 */
      void (*rte)(void);        /*! スケジューラへのポインタ */
    } rps_schdul;
    /*! Multilevel Feedback Queueエリア(スケジュール優先度は実装しない) */
    struct {
#define MFQ_TIME_SLICE 1000       /*! MFQスケジューリング,タイムスライスデフォルト値 */
      int tmout;                  /*! スケジューラへ渡すパラメータ(デフォルト時での標準タイムスライス) */
      TMR_OBJP tobjp;             /*! スケジューラが使用する対象タイマコントロールブロックを記録 */
      void (*rte)(void);        /*! スケジューラへのポインタ */
    } mfq_schdul;
    /*! 簡易O(1)スケジューリングエリア */
    struct {
#define ODRONE_SLICE_WEIGHT 100   /*! 簡易O(1)スケジューリング,タイムスライス重み値(h8はクロック20MHzのため) */
      int tmout;                  /*! タイムスライスのデフォルト値(とりあえずこの実装) */
      TMR_OBJP tobjp;             /*! スケジューラが使用する対象タイマコントロールブロックを記録 */
      void (*rte)(void);        /*! スケジューラへのポインタ */
    } odrone_schdul;
    /*!  Fair Schedulerエリア */
    struct {
#define FR_TIME_SLICE 1000      /*! FRスケジューリング,タイムスライスデフォルト値 */
      int tmout;                  /*! スケジューラへ渡すパラメータ(デフォルト時でのタイムスライス) */
      TMR_OBJP tobjp;             /*! スケジューラが使用する対象タイマコントロールブロックを記録 */
      void (*rte)(void);        /*! スケジューラへのポインタ */
    } fr_schdul;
    struct {
#define PFR_TIME_SLICE 1000       /*! PFRスケジューリング,タイムスライスデフォルト値 */
      int tmout;                  /*! スケジューラへ渡すパラメータ(デフォルト時でのタイムスライス) */
      TMR_OBJP tobjp;             /*! スケジューラが使用する対象タイマコントロールブロックを記録 */
      void (*rte)(void);        /*! スケジューラへのポインタ */
    } pfr_schdul;
    /*! Rate Monotonicエリア */
    struct {
      int unroll_rate;            /*! 周期最小公倍数(create()されたタスクまで) */
      int unroll_exetim;          /*! 周期に沿った最大実行時間(create()されたタスクまで).簡単化のため相対デッドライン時間とする */
      void (*rte)(void);          /*! スケジューラへのポインタ */
    } rms_schdul;
    /*! Deadline Monotonicエリア */
    struct {
      int unroll_dead;            /*! デッドライン最小公倍数(create()されたタスクまで) */
      int unroll_exetim;          /*! 周期に沿った最大実行時間(create()されたタスクまで).簡単化のため相対デッドライン時間とする */
      void (*rte)(void);          /*! スケジューラへのポインタ */
    } dms_schdul;
    /* Earliest Deadline Firstエリア */
    struct {
      void (*rte)(void);          /*! スケジューラへのポインタ */
    } edf_schdul;
    /* Least Laxity Firstエリア */
    struct {
      void (*rte)(void);          /*! スケジューラへのポインタ */
    } llf_schdul;
  } un;
} SCHDULCB;


/*! スケジューリング情報 */
/* ～スケジューラで共通で持つ情報～ */
struct scheduler_infomation {
  SCHDUL_TYPE type;               /*! スケジューリングタイプ */
  SCHDULCB *entry;                /*! スケジューラコントロールブロックポインタ */
} mg_schdul_info;


/*
 * これらはinit_tsk()生成でも使用される
 * パラメータを必要としないスケジューラは下記の定義はない
 */
/*! ラウンドロビンスケジューリングパラメータ情報 */
enum {
  RR_TMOUT_PARAM_NUMBER = 0,      /*! スケジューラコントロールブロックへ渡す第一パラメータ番号 */
  RR_PARAM_NUM,                   /*! パラメータの数 */
};


/*! ラウンドロビン×優先度スケジューリングパラメータ情報 */
enum {
  RR_PRI_TMOUT_PARAM_NUMBER = 0,  /*! スケジューラコントロールブロックへ渡す第一パラメータ番号 */
  RR_PRI_PARAM_NUM,               /*! パラメータの数 */
};


/*! Multilevel Feedback Queueパラメータ情報 */
enum {
  MFQ_TMOUT_PARAM_NUMBER = 0,     /*! スケジューラコントロールブロックへ渡す第一パラメータ番号 */
  MFQ_PARAM_NUM,                  /*! パラメータの数 */
};


/*! 簡易O(1)スケジューリングパラメータ情報 */
enum {
  ODRONE_TMOUT_PARAM_NUMBER = 0,  /*! スケジューラコントロールブロックへ渡す第一パラメータ番号 */
  ODRONE_PARAM_NUM,               /*! パラメータの数 */
};


/*! Fair Schedulerパラメータ情報 */
enum {
  FR_TMOUT_PARAM_NUMBER = 0,      /*! スケジューラコントロールブロックへ渡す第一パラメータ番号 */
  FR_PARAM_NUM,                   /*! パラメータの数 */
};


/*! Priority Fair Schedulerパラメータ情報 */
enum {
  PFR_TMOUT_PARAM_NUMBER = 0,     /*! スケジューラコントロールブロックへ渡す第一パラメータ番号 */
  PFR_PARAM_NUM,                  /*! パラメータの数 */
};


/*! システムコール処理(sel_schdul():スケジューラの切り替え) */
ER sel_schdul_isr(SCHDUL_TYPE type, long param);

/*! スケジューラの初期化 */
ER schdul_init(void);

/*! 指定されたTCBをどのタイプのレディーキューから抜き取るか分岐 */
void schedule(void);

/*! タイムスライス型スケジューリング環境下で割込みが発生しタイマブロックを排除するか検査する関数 */
//void check_tmslice_schedul(SOFTVEC type);

/*! Rate Monotonic専用，展開スケジューリングをするための関数 */
void set_unrolled_schedule_val(int rate, int exetim);


#endif
